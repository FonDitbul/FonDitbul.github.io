{"posts":[{"title":"First With Hexo","text":"Blog With Hexo !","link":"/2023/11/14/first/"},{"title":"Clean Architecture With Hexagonal Architecture (1)","text":"Clean Architecture (클린 아키텍처)란? 헥사고날 아키텍처(Hexagonal Architecture), 또는 포트 어댑터 아키텍처(Ports and Adapters Architecture)라고 불리는 소프트웨어 아키텍처 중 하나입니다. 소프트웨어는 시간이 지날수록 복잡해지고 요구사항은 계속 변화합니다. 개발자는 변화에 유연하게 대처할 수 있어야합니다. 복잡한 소프트웨어를 빠른 시간안에 수정해야합니다. 클린 아키텍처를 통해 이 문제를 해결하고자 합니다. 정책과 세부사항 소프트웨어 시스템은 두 가지 구성요소가 존재합니다. 정책 (Policy) 모든 업무 규칙(Business Rules)과 업무 절차(procedures) 를 구체화 고수준 추상화된 개념 ex) 예시: 데이터를 저장한다, 구역 배달료를 구한다 세부사항 (Detail) 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소 ex) 입출력 장치, 데이터베이스, 웹 시스템, 서버, 프레임워크 등등 저수준 세부적인 개념 ex) RDB에 데이터를 저장한다, 폴리곤 구역에 속한 배달건에 대해 배달료를 구한다 클린 아키텍처의 목표는 세부사항이 정책에 무관하게 만들 수 있는 시스템을 구축하는 것입니다. 왜 클린 아키텍처가 필요한가? 언제 어디서 요구사항이 변할지 모릅니다. 개발자는 항상 변화에 대응할 수 있어야 합니다. 변경사항을 간단하고 쉽게 적용할 수 있어야합니다. 소프트웨어 개발 비용의 증가를 결정짓는 주된 요인은 바로 이 변경사항의 범위와 형태에 있습니다. 개발자는 복잡도와 의존성이 증가한 소프트웨어를 변경하는 것을 두려워하기 때문입니다. 로버트 C. 마틴의 책 클린 아키텍처 중에 이런말이 있습니다. 프로그램을 동작 하게 만들기는 그리 어려운 일이 아니다. 하지만 제대로 만들기는 어렵다. 제대로 만들게 되면 소수의 프로그래머만으로 프로그램이 지속적으로 동작하도록 만들 수 있다. 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화 하는데 있다. 빨리가는 유일한 방법은 제대로 가는 것이다. Layer Entities (Domain) 도메인 계층 하나 이상의 프로그램 간에 공유됨 수명이 긴 객체 재사용성이 높으므로 변경될 가능성이 낮은 객체를 가짐 Use Cases (Application) 애플리케이션 계층 비즈니스 규칙을 포함한 계층 외부 요소에 영향을 받지 않아야함 Interface Adapter (Port) 바깥 계층에서 사용하기 편리하도록 유즈케이스, 엔티티 계층에서 데이터를 변환 Controller, Presenter External Interfaces (Infrastructure) 인프라 계층 시간이 지남에 따라 구성이 변경될 수 있음 엔티티 계층에 추상화 하여 도메인 계층에 영향을 주지 않고 인터페이스를 수정, 업데이트 가능 ex) DB, 웹 프레임워크, HTTP 모든 계층은 도메인에 의존하지만 다른계층들은 서로 의존하지 않습니다. 이를 위해 핵심 비즈니스 로직은 중앙의 도메인 영역에 위치하며, 입력과 출력을 처리하는 포트와 어댑터를 통해 외부와 소통합니다. 요약 개발을 진행하다보면 이곳 저곳 섞여있는 의존도와 복잡도로 인해 소프트웨어의 변경에 난항을 겪을 때가 많습니다. 이러한 아키텍처들을 통해 해결을 함과 동시에 요구사항의 변경과 유지보수에 용이한 아키텍처들을 활용함으로써 복잡도를 낮추는 방법을 알아보았습니다. 외부 세부사항에 의존하지 않습니다. 테스트하기 쉽고 변경하기 쉬워집니다. 고수준 정책 에만 의존하기에 저수준(구현체)에 문제가 되는 부분만 수정하기 용이합니다. 마무리 해당 아키텍처가 ‘100% 옳다’ 라는 것에는 동의하지는 않습니다. 단점에도 보았듯이 실제 구현할때 복잡도가 올라갑니다. 과한 추상화, 중복인것 같지만 거짓 중복인 것 같은 인터페이스들 등 단순하게 구현하기 어려워집니다. 상황에 따른 적절한 아키텍처를 적용해야 합니다. 하지만 그 이전에 좋은 아키텍처는 무엇인지 의존성을 제거하고 변경하기 쉬운 소프트웨어를 어떻게 만드는지에 대해 알아 보는 것은 필요합니다. 다음은 예시를 통해 실제 아키텍처를 구현해 보는 글을 작성하고자 합니다. 참고 책 클린 아키텍처 주니어 개발자의 클린 아키텍처 맛보기: https://techblog.woowahan.com/2647/","link":"/2023/11/28/Architecture/hexogonal-architecture-1/"},{"title":"Clean Architecture 구현 해보기 (2)","text":"이번에는 NestJs 프레임워크를 활용해 클린 아키텍처를 구현하는 예제를 만들어보고자 합니다. Clean Architecture 에 대한 자세한 설명은 1편을 참고해주세요. 기술스택 TypeScript, NestJs, PostgreSQL, TypeORM Node 와 npm, NestJs, ORM 등 에 대한 자세한 내용은 다루지 않겠습니다. Node, npm, NestCLI, PostgreSQL 등은 이미 설치, 설정 되어 있다는 가정하에 진행하겠습니다. 유저의 회원가입 만들기 먼저 개발을 진행할 유저의 회원가입에 대한 요구사항 기획, 설계를 간단하게 작성 후 구현해보도록 하겠습니다. 요구사항 유저는 입력받은 유저 id와 email로 회원가입 할 수 있다. 유저의 id는 중복될 수 없다. 유저의 email은 중복될 수 없다. 회원가입 한 데이터는 데이터베이스에 저장한다. 요구사항에 대한 설계 DB User 스키마 123id int4 increment PKuser_id varchar(40)email varchar(100) API12345method POSTpath /user/sign-upbody key type commnet userId string 필수, 사용하고자 하는 유저 아이디 'ex) test' email string 필수, 이메일 형식 'ex) test@gmail.com' 구현하기 NestJS Project 시작 하기 먼저 Nest 프로젝트를 생성합니다. 1nest new hexagonal-architecture 1cd hexagonal-architecture 필요 없는 파일들을 삭제하고 다음과 같은 폴더구조를 생성하겠습니다. user 폴더 안에 application, domain, infrastructure, interface 를 위와 같이 생성합니다. Domain Layer user domain class 만들기 123456// /user/domain/user.tsexport class User { id: number; userId: string; email: string;} service interface 만들기 123456// /user/domain/user.service.tsimport { UserSignUpIn } from &quot;../interface/user.in&quot;;export interface IUserService { signUp: (signUpIn: UserSignUpIn) =&gt; Promise&lt;void&gt;;} in, out interface port는 하단에서 작성합니다. 회원가입 로직을 위한 signUp 메서드를 생성합니다. repository interface 만들기12345678910// /user/domain/user.repository.tsimport { UserSignUpOut } from '../interface/user.out';import { User } from './user';export interface IUserRepository { signUp: (signUpOut: UserSignUpOut) =&gt; Promise&lt;void&gt;; findOneOrNullByUserId: (userId: User['userId']) =&gt; Promise&lt;User | null&gt;; findOneOrNullByEmail: (userId: User['email']) =&gt; Promise&lt;User | null&gt;;} findOneOrNullByUserId 메서드는 user_id 컬럼으로 user 테이블을 조회 하여 존재 할 경우 return 없을 경우 null을 return 합니다. findOneOrNullByEmail email 을 통해 user 테이블을 조회합니다. return 값은 위와 같습니다. Interface Layer in port interface 만들기1234// /user/interface/user.in.tsimport { User } from '../domain/user';export type UserSignUpIn = Pick&lt;User, 'userId' | 'email'&gt;; 외부에서 요청 받은 값이 서버 안으로 들어오는 interface 는 in 으로 정의합니다. 회원가입을 위해 userId와 email이 필요하기 때문에 Pick을 통해 정의합니다. out port interface 만들기1234// /user/interface/user.out.tsimport { User } from '../domain/user';export type UserSignUpOut = Pick&lt;User, 'userId' | 'email'&gt;; 서버에서 처리하는 데이터가 infrastructure 레이어를 통해 외부로 나가므로 out으로 정의합니다. Application Layer 비즈니스 로직 구현하기 도메인에 정의한 user.service.ts 의 구현체를 작성합니다. 12345678910111213141516171819202122232425262728293031// /user/application/user.service.tsimport { IUserService } from '../domain/user.service';import { Inject, Injectable } from '@nestjs/common';import { UserSignUpIn } from '../interface/user.in';import { IUserRepository } from '../domain/user.repository';@Injectable()export class UserService implements IUserService { constructor( @Inject('IUserRepository') private userRepository: IUserRepository, ) {} async signUp(signUpIn: UserSignUpIn): Promise&lt;void&gt; { const { userId, email } = signUpIn; const userByUserId = await this.userRepository.findOneOrNullByUserId(userId); if (userByUserId) { throw new Error('중복된 userId가 존재합니다.'); } const userByEmail = await this.userRepository.findOneOrNullByEmail(email); if (userByEmail) { throw new Error('중복된 email 이 존재합니다.'); } await this.userRepository.signUp({ userId, email }); return; }} Domain 레이어를 통해 구현체를 작성하였고 해당 Layer 에서는 repository 의 구현체에 대한 의존하고 있지 않습니다. 따라서 Repository 의 도메인만 참고하여 로직을 작성할 수 있게 됩니다. 로직 입력받은 userId를 통해 중복된 User 가 있는지 검사합니다. 같은 유저 아이디가 존재할 경우 에러가 발생하며 회원가입이 실패합니다. 입력받은 email을 통해 중복된 user 가 존재하는지 확인합니다. 같은 이메일이 존재할 경우 에러가 발생하며 회원가입이 실패합니다. 중복된 userId와 email이 없다면 새로운 유저를 생성합니다. 로직에 따른 test 코드 작성하기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// /user/application/user.service.spec.tsimport { UserService } from './user.service';import { IUserRepository } from '../domain/user.repository';import { User } from '../domain/user';import { UserSignUpOut } from '../interface/user.out';import { UserSignUpIn } from '../interface/user.in';class UserRepositoryMocking implements IUserRepository { findOneOrNullByEmail(email: User['email']): Promise&lt;User | null&gt; { return Promise.resolve(null); } findOneOrNullByUserId(userId: User['userId']): Promise&lt;User | null&gt; { return Promise.resolve(null); } signUp(signUpOut: UserSignUpOut): Promise&lt;void&gt; { return Promise.resolve(null); }}describe('User Service test', () =&gt; { const userRepositoryMocking = new UserRepositoryMocking(); const sut: UserService = new UserService(userRepositoryMocking); describe('유저 회원 가입 테스트', () =&gt; { it('유저 id 와 email 을 입력받아 회원가입에 성공한 경우', async () =&gt; { const givenSinUpIn: UserSignUpIn = { userId: 'user_1234', email: 'test@email.com', }; jest .spyOn(userRepositoryMocking, 'findOneOrNullByUserId') .mockResolvedValue(null); jest .spyOn(userRepositoryMocking, 'findOneOrNullByEmail') .mockResolvedValue(null); await sut.signUp(givenSinUpIn); }); it('유저 id가 중복되어 회원가입이 실패한 경우', async () =&gt; { const givenSinUpIn: UserSignUpIn = { userId: 'user_1234', email: 'test@email.com', }; const givenUser: User = { id: 1, userId: 'user_1234', email: 'test1234@email.com', }; jest .spyOn(userRepositoryMocking, 'findOneOrNullByUserId') .mockResolvedValue(givenUser); await expect(async () =&gt; sut.signUp(givenSinUpIn)).rejects.toThrowError( new Error('중복된 userId가 존재합니다.'), ); }); it('유저 id는 중복 X email 의 중복이 존재하는 경우', async () =&gt; { const givenSinUpIn: UserSignUpIn = { userId: 'user_1234', email: 'test@email.com', }; const givenUser: User = { id: 1, userId: 'user_123456', email: 'test@email.com', }; jest .spyOn(userRepositoryMocking, 'findOneOrNullByUserId') .mockResolvedValue(null); jest .spyOn(userRepositoryMocking, 'findOneOrNullByEmail') .mockResolvedValue(givenUser); await expect(async () =&gt; sut.signUp(givenSinUpIn)).rejects.toThrowError( new Error('중복된 email 이 존재합니다.'), ); }); });}); 아직 repository 의 구현체가 존재하지 않아도 테스트를 실행해보면 위와같이 테스트가 수행되는 것을 확인할 수 있습니다. Infrastructure Layer 1.1 controller 만들기 1234567891011121314151617181920// /user/infrastructure/user.controller.tsimport { Body, Controller, Inject, Post } from '@nestjs/common';import { UserSignUpDto } from './user.dto';import { IUserService } from '../domain/user.service';@Controller()export class UserController { constructor(@Inject('IUserService') private userService: IUserService) {} @Post('/user/sign-up') async signUp(@Body() signUpDto: UserSignUpDto) { const { userId, email } = signUpDto; await this.userService.signUp({ userId, email, }); return true; }} 1.2 DTO (data transfer object) 만들기 123456// /user/infrastructure/user.dto.tsexport class UserSignUpDto { readonly userId: string; readonly email: string;} Client의 요청에 필요한 Dto를 위와 같이 정의합니다. repository TypeORM 구현체 만들기 TypeORM을 통한 구현체 만들기 먼저 TypeORM에 필요한 라이브러리를 설치합니다. npm install –save @nestjs/typeorm typeorm pg Entity 만들기 12345678910111213141516// user/infrastructure/typeorm/user.typeorm.entity.tsimport { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';@Entity({ name: 'user',})export class UserEntity { @PrimaryGeneratedColumn('increment') id: number; @Column({ name: 'user_id' }) userId: string; @Column() email: string;} 파일 명에 해당 외부 라이브러리를 나타내는 typeorm을 표기합니다. Repository 구현체 만들기 123456789101112131415161718192021222324252627282930313233343536373839// user/infrastructure/typeorm/user.typeorm.repository.tsimport { IUserRepository } from '../../domain/user.repository';import { Injectable } from '@nestjs/common';import { InjectRepository } from '@nestjs/typeorm';import { Repository } from 'typeorm';import { UserEntity } from './user.typeorm.entity';import { UserSignUpOut } from '../../interface/user.out';import { User } from '../../domain/user';@Injectable()export class UserTypeormRepository implements IUserRepository { constructor( @InjectRepository(UserEntity) private repository: Repository&lt;UserEntity&gt;, ) {} private convert(entity: UserEntity): User { return entity; } async findOneOrNullByEmail(email: User['email']): Promise&lt;User | null&gt; { const oneUser = await this.repository.findOneBy({ email }); return this.convert(oneUser); } async findOneOrNullByUserId(userId: User['userId']): Promise&lt;User | null&gt; { const oneUser = await this.repository.findOneBy({ userId }); return this.convert(oneUser); } async signUp(signUpOut: UserSignUpOut): Promise&lt;void&gt; { const { userId, email } = signUpOut; await this.repository.save({ userId: userId, email: email }); return; }} TypeORM 라이브러리를 통해 domain 에 작성했던 메서드들을 실제 구현합니다. module 만들기 database module 만들기 12345678910111213// /database/database.module.tsimport { Module } from '@nestjs/common';import { TypeOrmModule } from '@nestjs/typeorm';import { UserEntity } from '../user/infrastructure/typeorm/user.typeorm.entity';@Module({ imports: [TypeOrmModule.forFeature([UserEntity])], controllers: [], providers: [], exports: [TypeOrmModule.forFeature([UserEntity])],})export class DatabaseModule {} database module을 따로 생성합니다. TypeORM 이라는 세부적인 선택사항은 해당 모듈에만 의존하도록 합니다. 다른 모듈에서는 database module만 import 하여 사용할 수 있도록 합니다. user module 만들기 12345678910111213141516171819202122// /user/user.module.tsimport { Module } from '@nestjs/common';import { UserController } from './infrastructure/user.controller';import { UserService } from './application/user.service';import { DatabaseModule } from '../database/database.module';import { UserTypeormRepository } from './infrastructure/typeorm/user.typeorm.repository';@Module({ imports: [DatabaseModule], controllers: [UserController], providers: [ { provide: 'IUserService', useClass: UserService, }, { provide: 'IUserRepository', useClass: UserTypeormRepository, }, ],})export class UserModule {} 모든 레이어에 의존성을 Module 파일에 위와 같의 정의합니다. interface 를 통한 DI에 자세한 내용 Custom providers app module 수정하기 123456789101112131415161718192021222324// /app.module.tsimport { Module } from '@nestjs/common';import { UserModule } from './user/user.module';import { TypeOrmModule } from '@nestjs/typeorm';@Module({ imports: [ UserModule, TypeOrmModule.forRoot({ type: 'postgres', host: 'localhost', port: 5432, username: 'postgres', password: 'postgres', database: 'hexagonal', autoLoadEntities: true, synchronize: false, logging: true, }), ], controllers: [], providers: [],})export class AppModule {} 예제 코드","link":"/2023/12/06/Architecture/hexogonal-architecture-2/"},{"title":"Github Action 과 S3로 웹 페이지 자동 배포하기","text":"Github Action 과 S3의 정적 호스팅 기능을 사용하여 코드가 push 될 때마다 웹 페이지를 자동 배포할 수 있는 방법을 알아보도록 하겠습니다. AWS IAM 만들기 먼저 IAM 을 통해 Github Action에서 사용할 계정을 만들어 보도록 하겠습니다. IAM 계정 생성하기 AWS 콘솔에서 IAM검색 후 사용자 &gt; 사용자 생성 클릭 IAM S3 권한 설정하기 권한 정책에서 AmazonS3fullAccess 를 선택하여 S3에 대한 모든 권한을 부여하는 계정을 생성합니다. IAM key 발급받기 여기서 access key와 private key 를 복사해서 하단의 github 에 붙여넣기 합니다. Github 설정하기 Github Repository 에서 Setting 을 다음과 같이 설정하기 Settings 하단에 Secrets and variables &gt; Actions 를 클릭 Repository secrets 에서 New repository secret를 클릭 IAM key 에서 받아온 값들을 그림과 같이 저장합니다. S3 버킷 정적 호스팅 설정하기1. s3 bucket 만들기 aws 콘솔에서 s3 검색 버킷 만들기 클릭 2. s3 bucket setting 엑세스 차단 설정 해제하기 해당 s3 버킷은 외부에서 접근을 해야하기 때문에 위와 같이 엑세스 차단 설정을 해제 해야 합니다. 3. s3 버킷 설정하기 생성된 버킷 클릭 &gt; 속성 탭 클릭 &gt; 하단에 정적 웹 사이트 호스팅 에서 편집 버튼을 클릭 인덱스 문서에 기본 페이지 파일을 입력합니다. 보통 index.html을 사용합니다. 4. s3 정책 다음과 같이 설정하기 버킷 &gt; 권한 탭 클릭 &gt; 버킷 정책에서 편집 클릭 후 아래와 같이 작성 및 적용123456789101112{ &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;PublicReadGetObject&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: &quot;*&quot;, &quot;Action&quot;: &quot;s3:GetObject&quot;, &quot;Resource&quot;: &quot;arn:aws:s3:::github-action.test/*&quot; } ]} github-action.test 은 설정한 s3 버킷 이름을 작성하여야 합니다. Github Actions yml 생성하기 호스팅 하고자 하는 Github Repository 에서 다음과 같은 파일을 생성합니다. 파일 이름은 변경해도 상관없으나 경로는 유지해야합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243# .github/workflows/deploy.ymlname: Front Deployon: push: branches: ['main']jobs: deploy: runs-on: ubuntu-latest# defaults:# run:# working-directory: ./ steps: - name: Checkout source code uses: actions/checkout@master - name: Cache node modules # node modules 캐싱 uses: actions/cache@v1 with: path: node_modules key: ${{ runner.OS }}-master-build-${{ hashFiles('**/yarn.lock') }} restore-keys: | ${{ runner.OS }}-build- ${{ runner.OS }}- - name: Install run: npm i - name: Build env: CI: false run: npm run build - name: Deploy env: AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }} AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }} run: | aws s3 cp \\ --recursive \\ --region ap-northeast-2 \\ build s3://github-action.test 상단의 on push branches 에 의해 main 브랜치에 push가 될때마다 해당 Github Action이 실행됩니다. 이후 해당 repository 에 actions 탭에서 제대로 완료되었는지 확인 끝 s3에 파일 업로드 확인 마지막 정적 웹사이트 호스팅 하단에 링크 클릭하면 제대로 출력되는지 확인!","link":"/2023/11/27/Deploy/githubaction_s3_auto_deploy/"},{"title":"prometheus + grafana with docker 구축","text":"prometheus + grafana with docker 사전 준비 docker docker-compose step 1 docker-compose.yml123456789101112131415161718192021222324252627282930313233version: '2.23.0'services: influxdb: image: bitnami/influxdb:1.8.5 container_name: influxdb ports: - &quot;8086:8086&quot; - &quot;8085:8088&quot; environment: - INFLUXDB_ADMIN_USER_PASSWORD=bitnami123 - INFLUXDB_ADMIN_USER_TOKEN=admintoken123 - INFLUXDB_HTTP_AUTH_ENABLED=false - INFLUXDB_DB=myk6db granafa: image: bitnami/grafana:latest ports: - &quot;4000:4000&quot; prometheus: image: prom/prometheus container_name: prometheus volumes: - &quot;./prometheus.yml:/prometheus/prometheus.yml&quot; ports: - &quot;9090:9090&quot; command: - '--web.enable-lifecycle' restart: always node-exporter: image: prom/node-exporter ports: - &quot;9100:9100&quot; Step 2 prometheus.yml1234567891011global: scrape_interval: 10sscrape_configs: - job_name: prometheus static_configs: - targets: - prometheus:9090 - job_name: node static_configs: - targets: - node-exporter:9100 Step docker up1sudo docker-compose up 출처: https://mxulises.medium.com/simple-prometheus-setup-on-docker-compose-f702d5f98579","link":"/2023/11/16/Infra/prometheus_grafana_docker/"}],"tags":[{"name":"Clean Architecture","slug":"Clean-Architecture","link":"/tags/Clean-Architecture/"},{"name":"Hexagonal Architecture","slug":"Hexagonal-Architecture","link":"/tags/Hexagonal-Architecture/"},{"name":"github action","slug":"github-action","link":"/tags/github-action/"},{"name":"aws s3","slug":"aws-s3","link":"/tags/aws-s3/"},{"name":"모니터링","slug":"모니터링","link":"/tags/%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81/"},{"name":"grafana","slug":"grafana","link":"/tags/grafana/"},{"name":"prometheus","slug":"prometheus","link":"/tags/prometheus/"},{"name":"docker","slug":"docker","link":"/tags/docker/"}],"categories":[{"name":"Backend","slug":"Backend","link":"/categories/Backend/"},{"name":"Deploy","slug":"Deploy","link":"/categories/Deploy/"},{"name":"Infra","slug":"Infra","link":"/categories/Infra/"},{"name":"Architecture","slug":"Backend/Architecture","link":"/categories/Backend/Architecture/"},{"name":"Front","slug":"Deploy/Front","link":"/categories/Deploy/Front/"},{"name":"Monitoring","slug":"Infra/Monitoring","link":"/categories/Infra/Monitoring/"}],"pages":[{"title":"","text":"정권기 과정을 즐기는 벡엔드 개발자 자기소개 개발 과정을 즐기며 이야기 하는 것을 좋아하는 2년차 Node 백엔드 개발자 정권기 입니다. 결과보다 과정에 있어 즐거움을 찾습니다. 문제 해결에 대한 이야기를 좋아합니다. 개발에 몰입했을 때 시간이 빨리 지나 있음에 성취감을 느낍니다. 변화에 대응이 쉽고 유지보수와 지속 가능한 애플리케이션에 대해 계속 고민합니다. 여러 개발 방법과 스터디를 통한 성장에 욕심이 있습니다. 항상 주어진 일에 책임감 있게 수행하고 더 만족도 높은 결과를 내고자 합니다. 능동적으로 일을 찾고 해결하고자 합니다. 스킬Backend Typescript, NestJs, Express Sequelize, Prisma PostgreSQL, MongoDB Jest, Sinon Frontend HTML, CSS React(기초 수준) Etc AWS Ec2, ALB, S3, RDS Docker Github Webstorm 경험사이드 프로젝트2023.04. ~copang[프로젝트 설명] 현업에서 발생할 법한 여러가지 이슈들의 해결, 개발 능력 향상을 위한 사이드 프로젝트 입니다. 이커머스 사이드 프로젝트 아키텍처, 테스트 코드, 리팩터링, 코드 관리 등에 집중하며 개발 [개발] Typescript, Nest, PostgreSQL, Prisma 스택 사용 외부 의존성 변화에 따른 개발을 최소화 하기 위한 Hexagonal 아키텍처 를 참고하여 구성 [인프라] 코드 관리 및 프로젝트 관리를 위한 모노레포 조직 git flow 브랜치 전략을 사용한 관리 [Copang Repository] 인졀미2022.03. ~ 2023.06.[프로젝트 설명] [우주두잇] 프로젝트는 아동청소년을 대상으로 한 게임형 건강관리 헬스케어 서비스이며 전국 52개 초등학교에서 3000여명의 사용자에게 서비스를 제공하는 업무를 담당하였습니다. 우주두잇 프로젝트 Backend 개발 [API 및 코드] 코드 컨벤션을 위한 eslint, prettier 를 통한 formatting 적용 Validation 코드의 관심사 분리와 불필요한 중복코드 제거를 위한 Middleware 활용 견고하며 확장성 있는 서버 코드를 위한 단위 테스트 코드 도입 및 약 2달간 테스트 케이스 234개 작성 [데이터베이스 개선] RDB 쿼리 실행 계획 및 인덱스를 활용한 성능 튜닝 작업 진행 메인 페이지 API 중 쿼리 속도 99% 개선 MongoDB 인덱스를 활용한 건강 데이터 중복 데이터 제거 속도 97% 개선 [인프라] APM Sentry On Premise 도입 기존 수동 배포 절차를 쉘 스크립트를 활용하여 자동화하여 배포시간 83% 감소 용량 부족시 수동으로 진행했던 서버 건강 데이터 s3에 자동 업로드 개선 AWS ec2, ALB를 활용한 365/24 서비스 제공 과제전형 대비 E-Commerce 마이크로 서비스 설계2023.04.17 ~ 2023.04.30[프로젝트 설명] [Numble] 에서 주관하는 [과제전형 대비 E-Commerce 마이크로 서비스 설계] 과제 E-commerce 상에서 쿠폰 기능을 도입하기 위한 가상의 환경을 통해 요구사항을 만족하는 범용적인 쿠폰(할인) 마이크로 서비스를 만드는 프로젝트 진행 Numble E-commerce 마이크로 서비스 설계 가이드라인 링크 [개발] Nest Js, Typescript, PostgreSQL, Prisma(ORM), gRPC의 기술 스택으로 개발 Redis 를 활용하여 쿠폰 동시 발급 이슈 해결 k6를 활용하여 성능 테스트 진행 지표 시각화를 위한 grafana 사용 [결과] 참가자 9명 중 TOP-1 달성 프로젝트 종료 후 Redis를 활용하여 150 RPS -&gt; 800 RPS 성능 개선 [Numble-Coupon Repository] GameLog-Server2021.08. ~ 2021.11.[프로젝트 설명] 대학교 캡스톤 디자인 으로 진행된 사용자 기반의 게임 평가, 게임 일기, 게임 추천 서비스 제공하는 앱 서비스 GameLog 개발 [개발] Javascript, express, mopngodb MVC 패턴에 따른 구현 [GameLog-Server Repository] 딥노이드2020.09 ~ 2021.02.[프로젝트 설명] 공항 X-ray를 통한 위해 물품 탐지 업무 보조 AI 위해물품 자동 탐지 어플리케이션 개발 프로젝트를 진행하였습니다. [개발] 레이블링을 편의성을 위한 내부 레이블링 사이트 유지보수 및 위해 물품 자동 탐지 어플리케이션 프론트엔드 개발 경력인졀미Node 백엔드 개발자 2022.03. ~ 2023.06. (1년 4개월) 헬스케업 플랫폼 스타트업 인졀미 회사 링크 딥노이드프론트 엔드 개발자 2020.09. ~ 2021.02. (6개월) 산업, 의료 AI 개발 관련 기업 딥노이드 회사 링크 학력광영고등학교 이과계열2012.03. ~ 2015.02. | 졸업 서울과학기술대학교대학교(학사) | 컴퓨터공학과2015.03. ~ 2022.02. | 졸업 자격증정보처리기사2021.11.","link":"/about/index.html"}]}